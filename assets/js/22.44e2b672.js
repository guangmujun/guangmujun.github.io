(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{598:function(t,n,e){"use strict";e.r(n);var a=e(7),r=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"线程的调度"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程的调度"}},[t._v("#")]),t._v(" 线程的调度")]),t._v(" "),e("h3",{attrs:{id:"基本用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基本用法"}},[t._v("#")]),t._v(" 基本用法")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("线程与进程的区别，多线程的性价比要优于多进程")])]),t._v(" "),e("li",[e("p",[t._v("一个进程默认自带一个线程，这个默认线程被称作主线程")])]),t._v(" "),e("li",[e("p",[t._v("基本使用")]),t._v(" "),e("p",[t._v("package com.jiangsu.nanjing;")])])]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('public class TestThread {\n   public static void main(String[] args){\n       CountThread thread = new CountThread();\n       thread.start();\n   }\n\n   private static class CountThread extends Thread{\n       public void run(){\n           for (int i=0; i<1000; i++){\n               PrintUtils.print(getName(), "Current Number:"+i);\n           }\n       }\n   }\n}\n')])])]),e("p",[t._v("​"),e("br"),t._v("\n​"),e("br"),t._v("\npackage com.jiangsu.nanjing;")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('import java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class PrintUtils {\n   public static void print(String threadName, String event){\n       SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss.SSS");\n       String dateTime = sdf.format(new Date());\n       String desc = String.format("%s %s %s", dateTime, threadName, event);\n       System.out.println(desc);\n   }\n}\n')])])]),e("p",[t._v("​")]),t._v(" "),e("ol",{attrs:{start:"4"}},[e("li",[e("p",[t._v("设置优先级")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v(" private static void testPriority(){\n  CountThread thread1 = new CountThread();\n  thread1.setPriority(1);\n  thread1.start();\n  CountThread thread2 = new CountThread();\n  thread2.setPriority(9);  //数字越大，优先级越高\n  thread2.start();\n")])])]),e("p",[t._v("}")])]),t._v(" "),e("li",[e("p",[t._v("中断机制")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('  private static class PassiveInterruptThread extends Thread{\n  public void run(){\n      try {\n          for (int i=0; i<1000; i++){\n              PrintUtils.print(getName(), "Current Number:"+i);\n              Thread.sleep(10);\n          }\n      }catch (InterruptedException e){\n          PrintUtils.print(getName(), "Interrupt");\n      }\n  }\n')])])]),e("p",[t._v("}")]),t._v(" "),e("p",[t._v("//睡眠500毫秒后中断"),e("br"),t._v("\nprivate static void testPassiveInterrupt(){\nPassiveInterruptThread thread = new PassiveInterruptThread();\nthread.start();\ntry {\nThread.sleep(500);\n}catch (InterruptedException e){\ne.printStackTrace();\n}\nthread.interrupt();\n}")])])]),t._v(" "),e("h3",{attrs:{id:"任务runnable"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#任务runnable"}},[t._v("#")]),t._v(" 任务Runnable")]),t._v(" "),e("p",[t._v("使用函数式接口，不用每次都去单独定义专门的线程类。")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("常规写法")]),t._v(" "),e("p",[t._v('private static class FactorialTask implements Runnable{\npublic void run(){\nint product = 1;\nfor (int i=1; i<=10; i++){\nproduct *= i;\n}\nPrintUtils.print(Thread.currentThread().getName(), "Result:"+product);\n}\n}')]),t._v(" "),e("p",[t._v("public static void main(String[] args){\nFactorialTask task = new FactorialTask();\nnew Thread(task).start();\n}")])]),t._v(" "),e("li",[e("p",[t._v("内部类的写法")]),t._v(" "),e("p",[t._v('public static void main(String[] args){\nnew Thread(new Runnable() {\n@Override\npublic void run() {\nint product = 1;\nfor (int i=1; i<=10; i++){\nproduct *= i;\n}\nPrintUtils.print(Thread.currentThread().getName(), "Result:"+product);\n}\n}).start();\n}')])]),t._v(" "),e("li",[e("p",[t._v("Lambda表达式写法")]),t._v(" "),e("p",[t._v('public static void main(String[] args){\nnew Thread(() -> {\nint product = 1;\nfor (int i=1; i<=10; i++){\nproduct *= i;\n}\nPrintUtils.print(Thread.currentThread().getName(), "Result:"+product);\n}).start();\n}')])]),t._v(" "),e("li",[e("p",[t._v("资源共享和分配 "),e("strong",[t._v("单独定义的线程类无法处理共享的事务")]),t._v(" 3个线程共同售卖100张票的示例：")]),t._v(" "),e("p",[t._v('public static void main(String[] args){\nRunnable seller = new Runnable() {\nprivate int ticketCount = 100;\n@Override\npublic void run() {\nwhile (ticketCount > 0){\nticketCount--;\nString left = String.format("Left: %d", ticketCount);\nPrintUtils.print(Thread.currentThread().getName(), left);\n}\n}\n};\nnew Thread(seller, "A").start();\nnew Thread(seller, "B").start();\nnew Thread(seller, "C").start();\n}')])])]),t._v(" "),e("h3",{attrs:{id:"过程callable"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#过程callable"}},[t._v("#")]),t._v(" 过程Callable")]),t._v(" "),e("p",[t._v("利用Callable接口构建任务代码，重写call方法，设置返回值。 创建一个线程，获取随机数示例：")]),t._v(" "),e("p",[t._v("​"),e("br"),t._v("\nCallable"),e("Integer",[t._v(" callable = () -> new Random().nextInt(100);")])],1),t._v(" "),e("p",[t._v("结合Callable和FutureTask跟踪任务的执行状态")]),t._v(" "),e("p",[t._v("​"),e("br"),t._v("\npublic static void main(String[] args){\nCallable"),e("Integer",[t._v(" callable = () -> new Random().nextInt(100);\nFutureTask"),e("Integer",[t._v("  future = new FutureTask"),e("Integer",[t._v('(callable);\nnew Thread(future).start();\ntry {\nInteger result = future.get();\nPrintUtils.print(Thread.currentThread().getName(), "Main Thread:"+result);\n}catch (InterruptedException | ExecutionException e){\ne.printStackTrace();\n}\n}')])],1)],1)],1),t._v(" "),e("h3",{attrs:{id:"定时器与定时任务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定时器与定时任务"}},[t._v("#")]),t._v(" 定时器与定时任务")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("TimerTask：描述时刻到达后的事务处理")])]),t._v(" "),e("li",[e("p",[t._v("Timer：用于调度定时任务")]),t._v(" "),e("ul",[e("li",[t._v("schedule：重载同名方法，下个任务在上个任务结束之后再间隔若干时间才启动")]),t._v(" "),e("li",[t._v("scheduleAtFixedRate：达到启动间隔即启动，下个任务不管上个任务何时结束")])]),t._v(" "),e("p",[t._v('private static class CountTask extends TimerTask{\nprivate int count = 0;\npublic void run(){\nPrintUtils.print(Thread.currentThread().getName(), "Result:"+count);\ncount++;\n}\n}')]),t._v(" "),e("p",[t._v("private static void testScheduleOnce(){\nCountTask timerTask = new CountTask();\nTimer timer = new Timer();\n//        timer.schedule(timerTask, 5000);\ntimer.schedule(timerTask, 5000, 1000);\ntry {\nThread.sleep(1000);\n}catch (InterruptedException e){\ne.printStackTrace();\n}\ntimer.cancel();\n}")])])]),t._v(" "),e("h2",{attrs:{id:"并发控制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#并发控制"}},[t._v("#")]),t._v(" 并发控制")]),t._v(" "),e("h3",{attrs:{id:"同步-关键字synchronized的用法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#同步-关键字synchronized的用法"}},[t._v("#")]),t._v(" 同步：关键字synchronized的用法")]),t._v(" "),e("p",[t._v("解决线程冲突问题\n可以修饰某个方法或者某个代码块，目的是限定该方法、代码块为同步方法/同步代码块，即规定同一时刻只能有一个线程执行同步方法，其他线程来了以后必须在旁边等待。")]),t._v(" "),e("p",[t._v("​"),e("br"),t._v("\npackage com.jiangsu.nanjing;")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('public class TestSync {\n    public static void main(String[] args){\n        testConflict();\n    }\n\n    private static void testConflict(){\n        Runnable seller = new Runnable() {\n            private Integer ticketCount = 100;\n            @Override\n            public void run() {\n                while (ticketCount > 0){\n                    int count = getDecreaseCount();\n                    String left = String.format("The left number is: %d", count);\n                    PrintUtils.print(Thread.currentThread().getName(), left);\n                }\n            }\n            private  synchronized int getDecreaseCount(){\n                return --ticketCount;\n            }\n        };\n        new Thread(seller, "A").start();\n        new Thread(seller, "B").start();\n        new Thread(seller, "C").start();\n    }\n}\n')])])]),e("p",[t._v("​")]),t._v(" "),e("h3",{attrs:{id:"通过加解锁避免资源冲突"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#通过加解锁避免资源冲突"}},[t._v("#")]),t._v(" 通过加解锁避免资源冲突")]),t._v(" "),e("p",[t._v("线程同步机制只适用于简单场合。 锁机制，可重入锁ReentrantLock，可重入即支持重新进入，加锁不是为了锁自己，是为了锁别人。")]),t._v(" "),e("p",[t._v("​"),e("br"),t._v("\nprivate final static ReentrantLock reentrantLock = new ReentrantLock();")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('    private static void testReentranLock(){\n        Runnable seller = new Runnable() {\n            private Integer ticketCount = 100;\n\n            @Override\n            public void run() {\n                while (ticketCount > 0){\n                    reentrantLock.lock();\n                    int count = --ticketCount;\n                    reentrantLock.unlock();\n                    String left = String.format("The left number is: %d", count);\n                    PrintUtils.print(Thread.currentThread().getName(), left);\n                }\n            }\n        };\n        new Thread(seller, "A").start();\n        new Thread(seller, "B").start();\n        new Thread(seller, "C").start();\n    }\n')])])]),e("p",[t._v("锁可细分为：读锁和写锁，读锁与读锁不互斥，读锁与写锁互斥，写锁与写锁互斥。 可重入读写锁： ReentranReadWriteLock")]),t._v(" "),e("p",[t._v("​"),e("br"),t._v("\nprivate final static ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\nprivate final static ReentrantReadWriteLock.WriteLock writeLock = readWriteLock.writeLock();\nprivate final static ReentrantReadWriteLock.ReadLock readLock = readWriteLock.readLock();")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('    private static void testReadWriteLock(){\n        Runnable seller = new Runnable() {\n            private Integer ticketCount = 100;\n            @Override\n            public void run() {\n                while (ticketCount > 0){\n                    int count = 0;\n                    try(FileOutputStream fos = new FileOutputStream("./test.txt")){\n                        readLock.lock();\n                        if (ticketCount <= 0){\n                            fos.close();\n                            readLock.unlock();\n                            break;\n                        }\n                        readLock.unlock();\n                        writeLock.lock();\n                        count = --ticketCount;\n                        writeLock.unlock();\n                        fos.write(new String(""+count).getBytes());\n                    }catch (Exception e){\n                        e.printStackTrace();\n                    }\n                    String left = String.format("The left number is: %d", count);\n                    PrintUtils.print(Thread.currentThread().getName(), left);\n                }\n            }\n        };\n        new Thread(seller, "A").start();\n        new Thread(seller, "B").start();\n        new Thread(seller, "C").start();\n    }\n')])])]),e("h3",{attrs:{id:"信号量semaphore的请求与释放"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#信号量semaphore的请求与释放"}},[t._v("#")]),t._v(" 信号量Semaphore的请求与释放")]),t._v(" "),e("p",[t._v("加锁比同步灵活，但是在高级场合仍然不使用。 信号量的关键在于量，里面保存的是许可证，并且许可证的数量不止一个，意味着有几个许可证，就允许几个线程一起处理。\n信号量支持多种请求许可证的方式，用于满足于丰富多样的业务需求，有：")]),t._v(" "),e("ul",[e("li",[t._v("坚持请求向信号量申请许可证，及时收到线程中断信号也不放弃")]),t._v(" "),e("li",[t._v("尝试向信号量申请许可证，但只愿意等待有限的时间")]),t._v(" "),e("li",[t._v("尝试向信号量立即申请许可证，哪怕一丁点时间都不愿意等待")]),t._v(" "),e("li",[t._v("尝试向信号量申请许可证，如果信号量无空闲许可证，那么愿意继续等待，但在等待期间允许接收中断信号")])]),t._v(" "),e("h3",{attrs:{id:"线程间的通信方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程间的通信方式"}},[t._v("#")]),t._v(" 线程间的通信方式")]),t._v(" "),e("p",[t._v("同步、加锁、信号量只适用于同一资源的共享分配")]),t._v(" "),e("ol",[e("li",[e("p",[t._v("同步机制下的线程通信")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("  private static Integer salary = 5000;\n")])])]),e("p",[t._v('private static void testWaitNotify(){\nRunnable employee = new Runnable() {\n@Override\npublic void run() {\nPrintUtils.print(Thread.currentThread().getName(), "Wait for salary");\nsynchronized (salary){\ntry{\nsalary.wait();  //等待发工资\nPrintUtils.print(Thread.currentThread().getName(), "Let\'s eat");\n}catch (InterruptedException e){\ne.printStackTrace();\n}\n}\n}\n};')]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('  Runnable boss = new Runnable() {\n      @Override\n      public void run() {\n          wait_a_moment();\n          PrintUtils.print(Thread.currentThread().getName(), "Give salary");\n          synchronized (salary){\n              wait_a_moment();\n              salary.notify();//在等待的队列中随机挑选一个线程发放通知\n              PrintUtils.print(Thread.currentThread().getName(), "Done salary");\n          }\n      }\n  };\n\n  new Thread(employee, "I\'m employee").start();\n  new Thread(boss, "I\'m boss").start();\n')])])]),e("p",[t._v("}")]),t._v(" "),e("p",[t._v("//模拟日常事物的时间消耗\nprivate static void wait_a_moment(){\nint delay = new Random().nextInt(500);\ntry{\nThread.sleep(delay);\n}catch (InterruptedException e){\ne.printStackTrace();\n}\n}")])]),t._v(" "),e("li",[e("p",[t._v("加锁机制下的线程通信")]),t._v(" "),e("p",[t._v("private final static ReentrantLock reentrantLock = new ReentrantLock();\nprivate static Condition condition = reentrantLock.newCondition();")]),t._v(" "),e("p",[t._v('private static void testCondition(){\nRunnable employee = new Runnable() {\n@Override\npublic void run() {\nPrintUtils.print(Thread.currentThread().getName(), "Wait Salary");\nreentrantLock.lock();\ntry{\ncondition.await();\nPrintUtils.print(Thread.currentThread().getName(), "Eat");\n}catch (InterruptedException e){\ne.printStackTrace();\n}\nreentrantLock.unlock();\n}\n};')]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('  Runnable boss = new Runnable() {\n      @Override\n      public void run() {\n          wait_a_moment();\n          PrintUtils.print(Thread.currentThread().getName(), "Give Salary");\n          reentrantLock.lock();\n          wait_a_moment();\n          condition.signal();\n          PrintUtils.print(Thread.currentThread().getName(), "Done salary");\n          reentrantLock.unlock();\n      }\n  };\n\n  new Thread(employee, "I\'m employee").start();\n  new Thread(boss, "I\'m boss").start();\n')])])]),e("p",[t._v("}")])])]),t._v(" "),e("h2",{attrs:{id:"线程池管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#线程池管理"}},[t._v("#")]),t._v(" 线程池管理")]),t._v(" "),e("ul",[e("li",[t._v("普通线程池：执行实时任务")]),t._v(" "),e("li",[t._v("定时器线程池：执行定时任务")]),t._v(" "),e("li",[t._v("分治框架：Fork/Join")])]),t._v(" "),e("h3",{attrs:{id:"普通线程池"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#普通线程池"}},[t._v("#")]),t._v(" 普通线程池")]),t._v(" "),e("p",[t._v("线程池封装了线程的创建、启动、关闭等操作，以及系统的资源分配与线程调度。 线程池的分类（按数量）：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("只有一个线程")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('private static void testSinglePool(){\n  ExecutorService pool = (ExecutorService) Executors.newSingleThreadExecutor();\n  for (int i=0; i<10; i++){\n      Operation operation = new Operation("Single Pool", i);\n      pool.execute(operation);\n  }\n  pool.shutdown();\n')])])]),e("p",[t._v("}")]),t._v(" "),e("p",[t._v("private static class Operation implements Runnable{\nprivate String name;\nprivate int index;")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('  public Operation(String name, int index){\n      this.name = name;\n      this.index = index;\n  }\n\n  public void run(){\n      String desc = String.format("%s do task %d", name, index+1);\n      PrintUtils.print(Thread.currentThread().getName(), desc);\n  }\n')])])]),e("p",[t._v("}")])])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://my-imags.oss-cn-shanghai.aliyuncs.com/pic/20201229114346.png",alt:""}})]),t._v(" "),e("ul",[e("li",[e("p",[t._v("固定数量的线程")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('private static void testFixedPool(){\n  ExecutorService pool = (ExecutorService) Executors.newFixedThreadPool(3);\n  for (int i=0; i<10; i++){\n      Operation operation = new Operation("Single Pool", i);\n      pool.execute(operation);\n  }\n  pool.shutdown();\n')])])]),e("p",[t._v("}")])])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://my-imags.oss-cn-shanghai.aliyuncs.com/pic/20201229114421.png",alt:""}})]),t._v(" "),e("ul",[e("li",[e("p",[t._v("有无限数量的线程")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('private static void testUnlimitPool(){\n  ExecutorService pool = (ExecutorService) Executors.newCachedThreadPool();\n  for (int i=0; i<10; i++){\n      Operation operation = new Operation("Single Pool", i);\n      pool.execute(operation);\n  }\n  pool.shutdown();\n')])])]),e("p",[t._v("}")])])]),t._v(" "),e("p",[t._v("​")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://my-imags.oss-cn-shanghai.aliyuncs.com/pic/20201229114527.png",alt:""}})]),t._v(" "),e("ul",[e("li",[e("p",[t._v("线程数量允许变化的线程池")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("private static void testCustomPool(){\n")])])]),e("p",[t._v("//最小线程个数为2，最大线程个数为5，每个线程保持活跃的时间为60，单位为秒，等待队列大小为19\nThreadPoolExecutor pool = new ThreadPoolExecutor(2, 5, 60,\nTimeUnit.SECONDS, new LinkedBlockingDeque"),e("Runnable",[t._v('(19));\nfor (int i=0; i<10; i++){\nOperation operation = new Operation("Pool", i);\npool.execute(operation);\n}\npool.shutdown();\n}')])],1)])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://my-imags.oss-cn-shanghai.aliyuncs.com/pic/20201229114817.png",alt:""}})]),t._v(" "),e("h3",{attrs:{id:"定时器线程池"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定时器线程池"}},[t._v("#")]),t._v(" 定时器线程池")]),t._v(" "),e("p",[t._v("要求在特定的时间点运行，并且不止运行以此，还要周期性地反复运行。 分类：")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("单线程的定时器线程池")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("package com.jiangsu.nanjing;\n")])])]),e("p",[t._v("import java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;")]),t._v(" "),e("p",[t._v("public class TestScheduled {\npublic static void main(String[] args){\ntestSingleScheduleOnce();\n}")]),t._v(" "),e("p",[t._v('private static void testSingleScheduleOnce(){\n//创建延迟一次的单线程定时器\nScheduledExecutorService pool = (ScheduledExecutorService) Executors.newSingleThreadScheduledExecutor();\nfor (int i=0; i<5; i++){\nVisit visit = new Visit("delay", i);//创建一个参观任务\npool.schedule(visit, 1, TimeUnit.SECONDS);//命令线程池调度任务，延迟1秒后执行参观任务\n}\n}')]),t._v(" "),e("p",[t._v("private static class Visit implements Runnable{\nprivate String name;\nprivate int index;\npublic Visit(String name, int index){\nthis.name = name;\nthis.index = index;\n}")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('  public void run(){\n      String desc = String.format("%s do task %d", name, index);\n      PrintUtils.print(Thread.currentThread().getName(), desc);\n  }\n')])])]),e("p",[t._v("}\n}")])]),t._v(" "),e("li",[e("p",[t._v("固定数量的定时器线程池")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("//固定速率\n")])])]),e("p",[t._v('private static void testMultiScheduleRate(){\n//固定数量，固定速率\nScheduledExecutorService pool = (ScheduledExecutorService) Executors.newScheduledThreadPool(3);\nfor (int i=0; i<5; i++){\nVisit visit = new Visit("specific rate", i);\n//第一次延迟1秒执行任务，以后每间隔3秒执行下一个任务\npool.scheduleAtFixedRate(visit, 1, 3, TimeUnit.SECONDS);\n}\n}')]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("//固定延迟\n")])])]),e("p",[t._v('private static void testMultiScheduleDelay(){\nScheduledExecutorService pool = (ScheduledExecutorService) Executors.newScheduledThreadPool(3);\nfor (int i=0; i<5; i++){\nVisit visit = new Visit("delay rate", i);\n//每3秒执行下一个任务\npool.scheduleWithFixedDelay(visit, 1, 3, TimeUnit.SECONDS);\n}\n}')])])]),t._v(" "),e("p",[e("img",{attrs:{src:"https://my-imags.oss-cn-shanghai.aliyuncs.com/pic/20201229120330.png",alt:""}})]),t._v(" "),e("p",[t._v("调度方式：")]),t._v(" "),e("ul",[e("li",[t._v("定时任务只启动一次")]),t._v(" "),e("li",[t._v("每间隔若干时间周期启动定时任务")]),t._v(" "),e("li",[t._v("固定延迟若干时间启动定时任务")])]),t._v(" "),e("h3",{attrs:{id:"分治框架爱fork-join"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#分治框架爱fork-join"}},[t._v("#")]),t._v(" 分治框架爱Fork/Join")]),t._v(" "),e("p",[t._v("线程池的内部线程之间没有什么关联，但是存在下级线程的任务由上级线程分配，而且下级线程的处理结果要交给上级线程汇总。")]),t._v(" "),e("ul",[e("li",[t._v("从上往下分解任务，Fork")]),t._v(" "),e("li",[t._v("最下面的基层线程操作具体的任务")]),t._v(" "),e("li",[t._v("从下往上逐级汇总任务结果，Join")])]),t._v(" "),e("p",[t._v("实例：计算0-100的和")]),t._v(" "),e("p",[t._v("​"),e("br"),t._v("\n//内部线程池\npackage com.jiangsu.nanjing;")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('public class TestForkJoinSum {\n    public static void main(String[] aegs){\n        testInternalTask();\n    }\n\n    private static void testInternalTask(){\n        int[] arr = new int[100];\n        for (int i=0; i<100; i++){\n            arr[i] = i + 1;\n        }\n        SumTask task = new SumTask(arr, 0, arr.length);\n        try {\n            Integer result = task.invoke();\n            System.out.println("The final result:"+result);\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n    }\n}\n')])])]),e("p",[t._v("​"),e("br"),t._v("\n​"),e("br"),t._v("\n​"),e("br"),t._v("\npackage com.jiangsu.nanjing;")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v('import java.util.concurrent.RecursiveTask;\n\npublic class SumTask extends RecursiveTask<Integer> {\n    private static final long serialVersionUID = 1L;\n    private static final int THRESHOLD = 20;\n    private int src[];\n    private int start;\n    private int end;\n\n    public SumTask(int[] src, int start, int end){\n        this.src = src;\n        this.start = start;\n        this.end = end;\n    }\n\n    private Integer subTotal(){\n        Integer sum = 0;\n        for (int i=start; i<end; i++){\n            sum += src[i];\n        }\n\n        String desc = String.format("%s the result of (%d - %d) = %d",\n                Thread.currentThread().getName(), start, end, sum);\n        System.out.println(desc);\n        return sum;\n    };\n\n    protected Integer compute(){\n        if ((end - start) <= THRESHOLD){\n            return subTotal();\n        }else {\n            int middle = (start + end) / 2;\n            SumTask left = new SumTask(src, start, middle);\n            left.fork();\n            SumTask right = new SumTask(src, middle, end);\n            right.fork();\n            int sum = left.join() + right.join();\n            String desc = String.format("%s the result of (%d - %d) = %d",\n                    Thread.currentThread().getName(), start, end, sum);\n            System.out.println(desc);\n            return sum;\n        }\n    }\n}\n')])])]),e("p",[t._v("​")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://my-imags.oss-cn-shanghai.aliyuncs.com/pic/20201229121644.png",alt:""}}),t._v("\n使用线程池工具ForkJoinPool，可设置开启的线程的数量，线程池内部进行统计")]),t._v(" "),e("p",[t._v("​"),e("br"),t._v("\n//外部显示指定ForkJoinPool\nprivate static void testPoolTask(){\nint[] arr = new int[100];\nfor (int i=0; i<100; i++){\narr[i] = i + 1;\n}\nSumTask task = new SumTask(arr, 0, arr.length);\nForkJoinPool pool = new ForkJoinPool(6);\nForkJoinTask"),e("Integer",[t._v(' taskResult = pool.submit(task);\ntry {\nInteger result = taskResult.get();\nSystem.out.println("The final result:"+result);\n}catch (Exception e){\ne.printStackTrace();\n}\npool.shutdown();\n}')])],1),t._v(" "),e("p",[e("img",{attrs:{src:"https://my-imags.oss-cn-shanghai.aliyuncs.com/pic/20201229122007.png",alt:""}})])])}),[],!1,null,null,null);n.default=r.exports}}]);