(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{608:function(t,e,i){"use strict";i.r(e);var n=i(7),a=Object(n.a)({},(function(){var t=this,e=t.$createElement,i=t._self._c||e;return i("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[i("h2",{attrs:{id:"容器的种类"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#容器的种类"}},[t._v("#")]),t._v(" 容器的种类")]),t._v(" "),i("h3",{attrs:{id:"集合hashset和treeset"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#集合hashset和treeset"}},[t._v("#")]),t._v(" 集合HashSet和TreeSet")]),t._v(" "),i("ol",[i("li",[i("p",[t._v("每个事物都是唯一的")])]),t._v(" "),i("li",[i("p",[t._v("Set属于接口，不能直接用来创建集合实例")])]),t._v(" "),i("li",[i("p",[t._v("Set的两个实现类：")]),t._v(" "),i("ol",[i("li",[t._v("HashSet（哈希集合）：采取哈希表来存储数据\n2. TreeSet（二叉集合）：采取二叉树来存储数据")])])]),t._v(" "),i("li",[i("p",[t._v("一开始使用集合，需要先创建该集合的实例")]),t._v(" "),i("p",[t._v("package com.jiangsu.nanjing;")])])]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v('import java.util.HashSet;\n\npublic class TestSet {\n   public static void main(String[] args){\n       testSet();\n\n   }\n\n   private static void testSet(){\n       HashSet<String> set = new HashSet<String>();\n       set.add("hello");\n       set.add("world");\n\n       System.out.println("set size:" + set.size());\n   }\n}\n')])])]),i("p",[t._v("​")]),t._v(" "),i("ol",{attrs:{start:"5"}},[i("li",[i("p",[t._v("for循环遍历")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v('      //for loop\n  for (String hash_item : set){\n      System.out.println("hash_item=" + hash_item);\n  }\n')])])])]),t._v(" "),i("li",[i("p",[t._v("迭代器遍历")]),t._v(" "),i("p",[t._v("// iterator loop\nIterator"),i("String",[t._v(' iterator = set.iterator();\nwhile (iterator.hasNext()){\nString hash_iterator = (String) iterator.next();\nSystem.out.println("hash_iterator=" + hash_iterator);\n}')])],1)]),t._v(" "),i("li",[i("p",[t._v("forEach遍历")]),t._v(" "),i("p",[t._v('// forEach loop\nset.forEach(hash_each -> System.out.println("hash_each=" + hash_each));')])]),t._v(" "),i("li",[i("p",[t._v("HashSet中元素是无序的，TreeSet中元素是有序的")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v('  private static void TestTreeSet(){\n  TreeSet<String> set = new TreeSet<String>();\n  set.add("hello");\n  set.add("world");\n  set.forEach(tree_each -> System.out.println("tree_each=" + tree_each));\n')])])]),i("p",[t._v("}")])]),t._v(" "),i("li",[i("p",[t._v("无论是哈希值计算，还是二叉节点比较，需要元素的归属数据类型提供计算方法或者比较方法，而对于开发者自己定义的数据类型，就要求开发者自己实现计算方法和比较方法")])])]),t._v(" "),i("h3",{attrs:{id:"映射-hashmap和treemap"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#映射-hashmap和treemap"}},[t._v("#")]),t._v(" 映射：HashMap和TreeMap")]),t._v(" "),i("ol",[i("li",[i("p",[t._v("映射指的是两个实体之间存在一对一的关系")])]),t._v(" "),i("li",[i("p",[t._v("通过键值对来表达映射关系")])]),t._v(" "),i("li",[i("p",[t._v("创建实例时必须同时指定键名和键值的数据类型")]),t._v(" "),i("p",[t._v('HashMap<String, MobilePhone> map = new HashMap<String, MobilePhone>();\nmap.put("Mate20", new MobilePhone("HuaWei", 600));\nmap.put("Honor10", new MobilePhone("Honor", 4000));')])]),t._v(" "),i("li",[i("p",[t._v("迭代器遍历（显示指针）")]),t._v(" "),i("p",[t._v("// iterator loop")])])]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v('Set<Map.Entry<String, MobilePhone>> entry_set = map.entrySet(); // 获得映射的集合入口\nIterator<Map.Entry<String, MobilePhone>> iterator = entry_set.iterator();// 获得映射的迭代器\nwhile (iterator.hasNext()){\n   Map.Entry<String, MobilePhone> iterator_item = iterator.next();\n   String key = iterator_item.getKey();\n   MobilePhone value = iterator_item.getValue();\n   System.out.println(String.format("iterator_item key=%s, value=%s %d",\n                                    key, value.getBrand(), value.getPrice()));\n}\n')])])]),i("ol",{attrs:{start:"5"}},[i("li",[i("p",[t._v("for循环遍历（隐式指针）")]),t._v(" "),i("p",[t._v("// for loop\nfor (Map.Entry<String, MobilePhone> for_item : map.entrySet()){\nString key = for_item.getKey();\nMobilePhone value = for_item.getValue();\n}")])]),t._v(" "),i("li",[i("p",[t._v("通过键名集合遍历")]),t._v(" "),i("p",[t._v("// key and value loop")])])]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("Set<String> key_set = map.keySet();\nfor (String key : key_set){\n   MobilePhone value = map.get(key);\n}\n")])])]),i("ol",{attrs:{start:"7"}},[i("li",[i("p",[t._v("forEach遍历")]),t._v(" "),i("p",[t._v("// forEach loop")])])]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v('map.forEach((key, value) ->\n           System.out.println(String.format("each_item key=%s, value=%s %d",\n                                            key, value.getBrand(), value.getPrice())));\n')])])]),i("h3",{attrs:{id:"清单-arraylist和linkedlist"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#清单-arraylist和linkedlist"}},[t._v("#")]),t._v(" 清单：ArrayList和LinkedList")]),t._v(" "),i("ol",[i("li",[t._v("集合和映射中每个元素都是唯一的，清单中元素允许重复加入，并且根据加入的顺序先后罗列")]),t._v(" "),i("li",[t._v("清单的实现类\n"),i("ol",[i("li",[t._v("ArrayList：列表、动态数组")])])]),t._v(" "),i("li",[t._v("Deque：队列，FIFO")]),t._v(" "),i("li",[t._v("Stack：栈，FILO")]),t._v(" "),i("li",[t._v("链表LinkedList，双端列表：清单、队列和栈的融合体")])]),t._v(" "),i("h2",{attrs:{id:"泛型的规则"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#泛型的规则"}},[t._v("#")]),t._v(" 泛型的规则")]),t._v(" "),i("h3",{attrs:{id:"泛型在方法中的使用"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#泛型在方法中的使用"}},[t._v("#")]),t._v(" 泛型在方法中的使用")]),t._v(" "),i("ol",[i("li",[i("p",[t._v("应对参数类型不确定的需求")])]),t._v(" "),i("li",[i("p",[t._v("泛型：空泛的类型，不明确的类型，在方法定义或者类定义的时候不确定类型，等到使用的时候再指定")])]),t._v(" "),i("li",[i("p",[t._v("类型泛化的代码格式："),i("code",[t._v("<T extends Object>")])])]),t._v(" "),i("li",[i("p",[t._v("由于Object是普通数据类型的基类，故上述格式可以简化为"),i("code",[t._v("<T>")])])]),t._v(" "),i("li",[i("p",[t._v("字符串拼接")]),t._v(" "),i("p",[t._v("public class TestClass {\npublic static void main(String[] args){\nDouble[] doubleArray = new Double[] {1.2, 2.3, 3.45553, 11.111};\nSystem.out.println(arraysToString(doubleArray));\n}")]),t._v(" "),i("p",[t._v("public static "),i("T",[t._v(' String arraysToString(T[] array){\nString result = "";\nif (array != null && array.length > 0){\nfor (int i = 0; i < array.length; i++){\nif (i > 0){\nresult = result + "|";\n}\nresult = result + array[i].toString();\n}\n}\nreturn result;\n}')])],1)])]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("}\n")])])]),i("h3",{attrs:{id:"泛型类定义及其运用"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#泛型类定义及其运用"}},[t._v("#")]),t._v(" 泛型类定义及其运用")]),t._v(" "),i("ol",[i("li",[t._v("利用清单List来保存数据，获取数据中最长的元素和最短的元素")])]),t._v(" "),i("p",[t._v("​"),i("br"),t._v("\npackage com.jiangsu.nanjing;")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("import java.util.List;\n\n//类名后面添加<T>，表示该类的内部代码中，所有的T类型都为外部需要时再制定类型\npublic class  SimpleList<T> {\n    private List<T> list;       //清单类型的数据类型为泛型T\n\n    //构造方法，传入要保存的清单数据\n    public SimpleList(List<T> list){\n        this.list = list;\n    }\n\n    //获取当前清单数据\n    public List<T> getData(){\n        return this.list;\n    }\n\n    //返回的数据类型为泛型T\n    public T getMaxLengthItem(){\n        if (list == null || list.size() <= 0){\n            return null;\n        }\n        T t = list.get(0);  //利用T声明一个泛型变量t\n        for (int i = 0; i < list.size(); i++){\n            if (list.get(i).toString().length() > t.toString().length()){\n                t = list.get(i);\n            }\n        }\n        return t;\n    }\n\n    public T getMinLengthItem(){\n        if (list == null || list.size() <= 0){\n            return null;\n        }\n        T t = list.get(0);\n        for (int i = 0; i < list.size(); i++){\n            if (list.get(i).toString().length() < t.toString().length()){\n                t = list.get(i);\n            }\n        }\n        return t;\n    }\n}\n")])])]),i("p",[t._v("​"),i("br"),t._v("\n​"),i("br"),t._v("\npackage com.jiangsu.nanjing;")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("import java.util.Arrays;\nimport java.util.List;\n\npublic class TestClass {\n    public static void main(String[] args){\n        List<Double> doubleList = Arrays.asList(1.1, 2.2, 3.1415, 11.11);\n        SimpleList<Double> simpleList = new SimpleList<Double>(doubleList);\n        System.out.println(simpleList.getMaxLengthItem());\n        System.out.println(simpleList.getMinLengthItem());\n    }\n\n}\n")])])]),i("p",[t._v("​")]),t._v(" "),i("h3",{attrs:{id:"java-8-新增的几种泛型接口"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#java-8-新增的几种泛型接口"}},[t._v("#")]),t._v(" Java 8 新增的几种泛型接口")]),t._v(" "),i("p",[t._v("泛型存在某种不确定的类型，因此很少直接运用于泛型类，常以泛型接口的形式出现。 "),i("strong",[t._v("断言接口Predicate")])]),t._v(" "),i("ol",[i("li",[t._v("用于匹配校验")])]),t._v(" "),i("p",[t._v("​"),i("br"),t._v("\npackage com.jiangsu.nanjing;")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v('import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.function.Predicate;\n\npublic class TestClass {\n    public static void main(String[] args){\n        testPredicate();\n    }\n\n    //获取默认的苹果清单\n    private static List<Apple> getAppleList(){\n        List<Apple> appleList = Arrays.asList(\n                new Apple("RedApple", "RED", 150d, 10d),\n                new Apple("RigApple", "green", 250d, 10d),\n                new Apple("RedApple", "red", 300d, 10d),\n                new Apple("BigApple", "yellow", 200d, 10d)\n        );\n        return appleList;\n    }\n\n    //利用系统自带的断言接口， 过滤某个清单里的元素\n    private static <T> List<T> filterByPredicate(List<T> list, Predicate<T> p){\n        List<T> result = new ArrayList<T>();\n        for (T t : list){\n            if (p.test(t)){\n                result.add(t);\n            }\n        }\n        return result;\n    }\n\n    //测试系统自带的断言接口\n    private static void testPredicate(){\n        List<Apple> appleList = getAppleList();\n        List<Apple> redAppleList = filterByPredicate(appleList, Apple::isRedApple);\n        System.out.println(redAppleList.toString());\n        List<Apple> heavyAppleList = filterByPredicate(appleList,\n                t -> t.getWeight() >= 250);\n        System.out.println(heavyAppleList.toString());\n    }\n}\n')])])]),i("p",[t._v("​")]),t._v(" "),i("p",[i("strong",[t._v("消费接口Consumer")])]),t._v(" "),i("ol",[i("li",[i("p",[t._v("用于数据修改")]),t._v(" "),i("p",[t._v("private static void testConsumer(){\nList"),i("Apple",[t._v(" appleList = getAppleList();\n//        modifyByConsumer(appleList, new Consumer"),i("Apple",[t._v('() {\n//            @Override\n//            public void accept(Apple apple) {\n//                apple.setName(apple.getName() + "Yummy");\n//            }\n//        });\nmodifyByConsumer(appleList, t -> t.setName(t.getName() + "Yummy"));\nSystem.out.println(appleList.toString());')])],1)],1)])]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("}\n\nprivate static <T> void modifyByConsumer(List<T> list, Consumer<T> c){\n   for (T t : list){\n       c.accept(t);\n   }\n}\n")])])]),i("ol",{attrs:{start:"2"}},[i("li",[i("p",[t._v("联合使用断言接口和消费接口")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("  private static void testPredicateAndConsumer(){\n  List<Apple> appleList = getAppleList();\n  selectAndModify(appleList, t -> t.isRedApple(),\n          t -> t.setPrice(t.getPrice() * 1.5));\n  selectAndModify(appleList, t -> t.getWeight() >= 250,\n          t -> t.setPrice(t.getPrice() * 1.5));\n  System.out.println(appleList.toString());\n")])])]),i("p",[t._v("}")]),t._v(" "),i("p",[t._v("private static "),i("T",[t._v(" void selectAndModify(List"),i("T",[t._v(" list, Predicate"),i("T",[t._v(" p,\nConsumer"),i("T",[t._v(" c){\nfor (T t : list){\nif (p.test(t)){\nc.accept(t);\n}\n}\n}")])],1)],1)],1)],1)])]),t._v(" "),i("p",[i("strong",[t._v("函数接口Function")])]),t._v(" "),i("ol",[i("li",[i("p",[t._v("用于数据抽取")])]),t._v(" "),i("li",[i("p",[t._v("联合断言和消费接口的问题在于：破坏了原始数据，未抽取到新清单")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("  private static void testFunction(){\n  List<Apple> appleList = getAppleList();\n  List<Apple> appleRecentList;\n  appleRecentList = recycleByFunction(appleList,\n          new Function<Apple, Apple>() {\n              @Override\n              public Apple apply(Apple t) {\n                  Apple apple = new Apple(t.getName(), t.getColor(),\n                          t.getWeight(), t.getPrice());\n                  if (apple.isRedApple()){\n                      apple.setPrice(apple.getPrice() * 1.5);\n                  }\n                  if (apple.getWeight() >= 250){\n                      apple.setPrice(apple.getPrice() * 1.5);\n                  }\n                  return apple;\n              }\n          });\n  System.out.println(appleRecentList.toString());\n")])])]),i("p",[t._v("}")]),t._v(" "),i("p",[t._v("private static <T, R> List"),i("R",[t._v(" recycleByFunction(List"),i("T",[t._v(" list, Function<T, R> f){\nList"),i("R",[t._v(" result = new ArrayList"),i("R",[t._v("();\nfor (T t : list){\nR r = f.apply(t);\nresult.add(r);\n}\nreturn result;\n}")])],1)],1)],1)],1)])]),t._v(" "),i("h2",{attrs:{id:"容器的加工"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#容器的加工"}},[t._v("#")]),t._v(" 容器的加工")]),t._v(" "),i("h3",{attrs:{id:"容器与数组互转"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#容器与数组互转"}},[t._v("#")]),t._v(" 容器与数组互转")]),t._v(" "),i("ol",[i("li",[t._v("容器转数组：出了映射Set之外，集合Set和清单List都支持通过toArray方法转化为数组")]),t._v(" "),i("li",[t._v("通过Arrays.asList得到的清单对象不能添加或删除元素")])]),t._v(" "),i("h3",{attrs:{id:"容器工具collections"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#容器工具collections"}},[t._v("#")]),t._v(" 容器工具Collections")]),t._v(" "),i("ol",[i("li",[i("p",[t._v("清单对应的容器工具")]),t._v(" "),i("p",[t._v("Collections.sort(appleList, (o1, o2) -> o1.getWeight().compareTo(o2.getWeight()))")])]),t._v(" "),i("li",[i("p",[t._v("Collections的方法有：sort，min，max， fill， swap")])])]),t._v(" "),i("h3",{attrs:{id:"java8新增的流式处理"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#java8新增的流式处理"}},[t._v("#")]),t._v(" Java8新增的流式处理")]),t._v(" "),i("ol",[i("li",[i("p",[t._v("由开发者事先定义一批处理命令，说明清楚每条指令的前因后果，然后启动流水线作业，即可得到最终的处理结果。")])]),t._v(" "),i("li",[i("p",[t._v("处理过程包含三个步骤")])]),t._v(" "),i("li",[i("p",[t._v("获得容器的流对象")]),t._v(" "),i("ol",[i("li",[t._v("串行流：stream\n2. 并行流：parallelStream")])])]),t._v(" "),i("li",[i("p",[t._v("设置流的各项筛选和加工指令")]),t._v(" "),i("ol",[i("li",[t._v("filter，sorted，map，limit，distinct")])])]),t._v(" "),i("li",[i("p",[t._v("规划处理结果的展示形式")]),t._v(" "),i("ol",[i("li",[t._v("包装流水线生产出来的数据\n2. count，forEach，collect\n3. 每次流水作业必须有且仅有一条结束指令")])])]),t._v(" "),i("li",[i("p",[t._v("示例")]),t._v(" "),i("p",[t._v("public class TestStream {\npublic static void main(String[] args){\n//按照名称统计红苹果的分组总价\nMap<String, Double> redPriceSum = getAppleList().stream()\n.filter(Apple::isRedApple)\n.collect(Collectors.groupingBy(Apple::getName, Collectors.summingDouble(Apple::getPrice)));\nSystem.out.println(redPriceSum);")]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v("  //按照名称统计红苹果的分组个数\n")])])])])]),t._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[t._v('//        Map<String, Long> redStatisticCount = getAppleList().stream()\n//                .filter(Apple::isRedApple)\n//                .collect(Collectors.groupingBy(Apple::getName, Collectors.counting()));\n//        System.out.println(redStatisticCount);\n\n       //挑选出去重后的苹果名称清单\n//        List<String> allNameList = getAppleList().stream()\n//                .map(Apple::getName)\n//                .distinct()\n//                .collect(Collectors.toList());\n//        System.out.println(allNameList);\n\n       //挑选出红苹果清单，按苹果重量升序排列\n//        List<Apple> redAppleList = getAppleList().stream()\n//                .filter(Apple::isRedApple)\n//                .sorted(Comparator.comparing(Apple::getWeight))\n//                .limit(1)\n//                .distinct()\n//                .collect(Collectors.toList());\n//        System.out.println(redAppleList.toString());\n\n       //对每个红苹果依次处理\n//        getAppleList().stream()\n//                .filter(Apple :: isRedApple)\n//                .forEach(s -> System.out.println(s.getColor()));\n\n       //统计出红苹果的总数\n//        long redCount = getAppleList().stream()\n//                .filter(Apple :: isRedApple)\n//                .count();\n//        System.out.println(redCount);\n   }\n\n   //获取默认的苹果清单\n   private static List<Apple> getAppleList(){\n       List<Apple> appleList = Arrays.asList(\n               new Apple("RedApple", "RED", 150d, 10d),\n               new Apple("RigApple", "green", 250d, 10d),\n               new Apple("RedApple", "red", 300d, 10d),\n               new Apple("BigApple", "yellow", 200d, 10d)\n       );\n       return appleList;\n   }\n}\n')])])])])}),[],!1,null,null,null);e.default=a.exports}}]);