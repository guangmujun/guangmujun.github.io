(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{629:function(_,t,n){"use strict";n.r(t);var r=n(7),p=Object(r.a)({},(function(){var _=this,t=_.$createElement,n=_._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[n("h2",{attrs:{id:"表的加减法"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#表的加减法"}},[_._v("#")]),_._v(" 表的加减法")]),_._v(" "),n("h3",{attrs:{id:"union"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#union"}},[_._v("#")]),_._v(" UNION")]),_._v(" "),n("ul",[n("li",[n("p",[_._v("对多张表进行求并集运算")])]),_._v(" "),n("li",[n("p",[_._v("对一张表也可以进行并集运算")])]),_._v(" "),n("li",[n("p",[_._v("通常会去除重复的记录")])]),_._v(" "),n("li",[n("p",[_._v("不去重的话，在UNION后面加ALL关键字")])]),_._v(" "),n("li",[n("p",[_._v("bag与set模型")]),_._v(" "),n("ul",[n("li",[_._v("bag类型中的数据允许重复，而set类型中的元素是互异的")]),_._v(" "),n("li",[_._v("bag的并运算：1. 该元素是否至少在一个bag里出现过 2.该元素在两个bag中的最大出现次数")])]),_._v(" "),n("p",[_._v("SELECT product_id, product_name\nFROM product\nUNION\nSELECT product_id, product_name\nFROM product_2;")])])]),_._v(" "),n("h3",{attrs:{id:"intersect"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#intersect"}},[_._v("#")]),_._v(" INTERSECT")]),_._v(" "),n("p",[_._v("交运算，MySQL8.0不支持")]),_._v(" "),n("h3",{attrs:{id:"except"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#except"}},[_._v("#")]),_._v(" EXCEPT")]),_._v(" "),n("p",[_._v("减法运算，MySQL8.0不支持，可使用NOT IN来实现表的减法运算。")]),_._v(" "),n("p",[_._v("​"),n("br"),_._v("\nSELECT *\nFROM product\nWHERE product_id NOT IN (SELECT product_id FROM product2)")]),_._v(" "),n("p",[_._v("EXCEPT ALL 按出现次数进行减法，也是使用bag模型进行运算，运算示例：")]),_._v(" "),n("blockquote",[n("p",[_._v("这两个方面来进行计算. 只有属于被减数的bag的元素才参与EXCEP ALL运算,\n并且差bag中的次数,等于该元素在两个bag的出现次数之差(差为零或负数则不出现). 因此对于 A = {1,1,1,2,3,5,7}, B =\n{1,1,2,2,4,6,8} 两个 bag, 它们的差就等于 {1,3,5,7}.")])]),_._v(" "),n("h3",{attrs:{id:"对称差"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#对称差"}},[_._v("#")]),_._v(" 对称差")]),_._v(" "),n("p",[_._v("两个集合的对称差等于A-B并上B-A 使用NOT IN 和 UNION实现")]),_._v(" "),n("h2",{attrs:{id:"连结join"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#连结join"}},[_._v("#")]),_._v(" 连结JOIN")]),_._v(" "),n("h3",{attrs:{id:"inner-join"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#inner-join"}},[_._v("#")]),_._v(" INNER JOIN")]),_._v(" "),n("p",[_._v("​"),n("br"),_._v("\nFROM "),n("tb1",[_._v(" INNER JOIN "),n("tb2",[_._v(" ON <condition(s)>")])],1)],1),_._v(" "),n("p",[_._v("​"),n("br"),_._v("\n​"),n("br"),_._v("\nSELECT SP.shop_id,SP.shop_name, SP.product_id, P.product_name,\nP.product_type, P.sale_price, SP.quantity\nFROM shopproduct AS SP\nINNER JOIN product AS P\nON SP.product_id = P.product_id;")]),_._v(" "),n("p",[_._v("结合WHERE子句使用内连结")]),_._v(" "),n("p",[_._v("​"),n("br"),_._v("\nSELECT *\nFROM (-- 第一步查询的结果\nSELECT SP.shop_id\n,SP.shop_name\n,SP.product_id\n,P.product_name\n,P.product_type\n,P.sale_price\n,SP.quantity\nFROM shopproduct AS SP\nINNER JOIN product AS P\nON SP.product_id = P.product_id) AS STEP1\nWHERE shop_name = '东京'\nAND product_type = '衣服' ;")]),_._v(" "),n("p",[_._v("上述的标准写法： 执行顺序为：FROM -> WHERE -> SELECT")]),_._v(" "),n("p",[_._v("​"),n("br"),_._v("\nSELECT  SP.shop_id\n,SP.shop_name\n,SP.product_id\n,P.product_name\n,P.product_type\n,P.sale_price\n,SP.quantity\nFROM shopproduct AS SP\nINNER JOIN product AS P\nON SP.product_id = P.product_id\nWHERE SP.shop_name = '东京'\nAND P.product_type = '衣服' ;")]),_._v(" "),n("p",[_._v("结合GROUP BY子句使用内连结")]),_._v(" "),n("p",[_._v("​"),n("br"),_._v("\nSELECT SP.shop_id, SP.shop_name,\nMAX(P.sale_price) AS max_price\nFROM shopproduct AS SP\nINNER JOIN product AS P\nON SP.product_id = P.product_id\nGROUP BY SP.shop_id, SP.shop_name")]),_._v(" "),n("h3",{attrs:{id:"self-join"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#self-join"}},[_._v("#")]),_._v(" SELF JOIN")]),_._v(" "),n("p",[_._v("自连结可以是外连结也可以是内连结 内连结与关联子查询找出每个商品种类当中售价高于该类商品的平均售价的商品")]),_._v(" "),n("p",[_._v("​"),n("br"),_._v("\nSELECT  P1.product_id\n,P1.product_name\n,P1.product_type\n,P1.sale_price\n,P2.avg_price\nFROM product AS P1\nINNER JOIN\n(SELECT product_type,AVG(sale_price) AS avg_price\nFROM product\nGROUP BY product_type) AS P2\nON P1.product_type = P2.product_type\nWHERE P1.sale_price > P2.avg_price;")]),_._v(" "),n("h3",{attrs:{id:"natural-join"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#natural-join"}},[_._v("#")]),_._v(" NATURAL JOIN")]),_._v(" "),n("p",[_._v("自然连结，是内连结的一种特例，会按照两个表中都包含的列名进行等值内连结，无需使用ON来指定连结条件。")]),_._v(" "),n("p",[_._v("​"),n("br"),_._v("\nSELECT * FROM shopproduct NATURAL JOIN product")]),_._v(" "),n("p",[_._v("求出两张表或子查询的公共部分")]),_._v(" "),n("p",[_._v("​"),n("br"),_._v("\nSELECT * FROM product NATURAL JOIN product2")]),_._v(" "),n("p",[_._v("注意字段为空的情况：")]),_._v(" "),n("p",[_._v("​"),n("br"),_._v("\nSELECT *\nFROM (SELECT product_id, product_name\nFROM product) AS A\nNATURAL JOIN\n(SELECT product_id, product_name\nFROM product2) AS B;")]),_._v(" "),n("p",[_._v("使用连结求交集")]),_._v(" "),n("p",[_._v("​"),n("br"),_._v("\nSELECT P1.*\nFROM product AS P1\nINNER JOIN product2 AS P2\nON P1.product_id = P2.product_id")]),_._v(" "),n("h3",{attrs:{id:"outer-join"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#outer-join"}},[_._v("#")]),_._v(" OUTER JOIN")]),_._v(" "),n("p",[_._v("外连结，根据外连结的种类有选择的保留无法匹配到的行")]),_._v(" "),n("ul",[n("li",[n("p",[_._v("左连结")]),_._v(" "),n("ul",[n("li",[_._v("保留左表中无法按照ON子句匹配到的行，此时对应右表的行均为缺失值")])])]),_._v(" "),n("li",[n("p",[_._v("右连结")])]),_._v(" "),n("li",[n("p",[_._v("全外连结")]),_._v(" "),n("ul",[n("li",[_._v("同时保留两个表中无法按照ON子句匹配到的行，相应的另一张表中的行用缺失值填充")])]),_._v(" "),n("p",[_._v("FROM "),n("tb1",[_._v(" LEFT OUTER JOIN "),n("tb2",[_._v(" ON <condition(s)>\nFROM "),n("tb1",[_._v(" RIGHT OUTER JOIN "),n("tb2",[_._v(" ON <condition(s)>\nFROM "),n("tb1",[_._v(" FULL OUTER JOIN "),n("tb2",[_._v(" ON <condition(s)>")])],1)],1)],1)],1)],1)],1)])]),_._v(" "),n("p",[_._v("左连结示例：")]),_._v(" "),n("p",[_._v("​"),n("br"),_._v("\nSELECT SP.shop_id\n,SP.shop_name\n,SP.product_id\n,P.product_name\n,P.sale_price\nFROM product AS P\nLEFT OUTER JOIN shopproduct AS SP\nON SP.product_id = P.product_id;")]),_._v(" "),n("p",[_._v("和WHERE结合使用：")]),_._v(" "),n("p",[_._v("​"),n("br"),_._v("\nSELECT P.product_id\n,P.product_name\n,P.sale_price\n,SP.shop_id\n,SP.shop_name\n,SP.quantity\nFROM product AS P\nLEFT OUTER JOIN-- 先筛选quantity<50的商品\n(SELECT *\nFROM shopproduct\nWHERE quantity < 50 ) AS SP\nON SP.product_id = P.product_id")]),_._v(" "),n("p",[_._v("多表连结： 适用于内连结和外连结 ON子句中可以使用逻辑运算符作为连结条件")]),_._v(" "),n("h3",{attrs:{id:"cross-join"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cross-join"}},[_._v("#")]),_._v(" CROSS JOIN")]),_._v(" "),n("p",[_._v("交叉连结，笛卡尔积 交叉连结是对两张表中的全部记录进行交叉组合,因此结果中的记录数通常是两张表中行数的乘积.本例中,因为 shopproduct 表存在\n13 条记录,product 表存在 8 条记录,所以结果中就包含了 13 × 8 = 104 条记录.")])])}),[],!1,null,null,null);t.default=p.exports}}]);