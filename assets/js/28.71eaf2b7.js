(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{604:function(a,t,n){"use strict";n.r(t);var e=n(7),s=Object(e.a)({},(function(){var a=this,t=a.$createElement,n=a._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h2",{attrs:{id:"类的嵌套"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类的嵌套"}},[a._v("#")]),a._v(" 类的嵌套")]),a._v(" "),n("ol",[n("li",[n("p",[a._v("内部类定义")]),a._v(" "),n("p",[a._v("public class Tree{\n// Flower类位于Tree类内部，是一个内部类")])])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("public class Flower{  \n}\n}\n")])])]),n("ol",{attrs:{start:"2"}},[n("li",[n("p",[a._v("内部类调用")]),a._v(" "),n("p",[a._v("// 先创建外部实例")])])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("Tree tree = new Tree();\n// 根据外部实例，创建内部类的实例\nTree.Flower flower = tree.new.Flower();\n")])])]),n("ol",{attrs:{start:"3"}},[n("li",[n("p",[a._v("嵌套类定义")]),a._v(" "),n("ol",[n("li",[a._v("静态的内部类：在内部类的前面添加关键字"),n("code",[a._v("static")])])]),a._v(" "),n("p",[a._v("public class TreeNest{\npublic static class Flower{\n// 嵌套类与外层类的关系，比一般的内部类要弱\n}")])])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("}\n")])])]),n("ol",{attrs:{start:"4"}},[n("li",[n("p",[a._v("嵌套类调用")]),a._v(" "),n("ol",[n("li",[a._v("直接创建嵌套类的实例")])]),a._v(" "),n("p",[a._v("TreeNest.Flower flower = new TreeNest.Flower();")])]),a._v(" "),n("li",[n("p",[a._v("静态：关键字"),n("code",[a._v("static")]),a._v("的用法")]),a._v(" "),n("ol",[n("li",[a._v("可以修饰类、成员方法、成员属性\n2. 如"),n("code",[a._v("Math.round")]),a._v("等就是静态的方法，外部可直接通过“类名.静态方法名”进行访问\n3. 静态属性：取值固定不变\n4. 静态方法：只允许操作输入参数")])]),a._v(" "),n("p",[a._v("public static int TYPE_ARBOR = 1;")])])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("public static String getTypeName(int type){\n\n}\n")])])]),n("p",[a._v("​"),n("br"),a._v("\nTreeStatic.TYPE_ARBOR;\nTreeStatic.getTypeName(TreeStatic.TYPE_ARBOR);")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("5. `static`修饰代码块：静态代码块的执行时机先于该类的构造方法\n\n    static{\n\n}\n\n\n6. `final static`表示该属性是允许赋值一次\n\n    public final static int FINAL_TYPE_ARBOR = 1;\n")])])]),n("ol",{attrs:{start:"6"}},[n("li",[n("p",[a._v("枚举类型标准定义")]),a._v(" "),n("ol",[n("li",[a._v("枚举：某些同类型常量的有限集合")])]),a._v(" "),n("p",[a._v("public enum Season{\nSPRING, SUMMER, AUTUMN, WINTER")])])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("}\n")])])]),n("p",[a._v("​"),n("br"),a._v('\nprivate static void testEnum(){\nSeason spring = Season.SPRING;\nSystem.out.println("序号：" + spring.ordinal() + "名称：" + spring.toString());\n}')]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("2. 枚举类型的通用方法：`ordinal`获取枚举的序号，`toString`获取枚举的字段名称\n")])])]),n("ol",{attrs:{start:"7"}},[n("li",[n("p",[a._v("枚举类型的自定义")]),a._v(" "),n("ol",[n("li",[a._v("枚举类型enum源自类class，因此枚举允许定义自己的成员属性、方法和构造方法")])]),a._v(" "),n("p",[a._v('public enum SeasonCn{\nSPRING(1, "春天"), SUMMER(2, "夏天"), AUTUMN(3, "秋天"), WINTER(4, "冬天");')]),a._v(" "),n("p",[a._v("private int value;\nprivate String name;")]),a._v(" "),n("p",[a._v("private SeasonCn(int value, String name){\nthis.value = value;\nthis.name = name;\n}")]),a._v(" "),n("p",[a._v("public int getValue(){\nreturn this.value;\n}")]),a._v(" "),n("p",[a._v("public String getName(){\nreturn this.name;\n}")])])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("}\n")])])]),n("p",[a._v("​"),n("br"),a._v('\nprivate static void testEnum(){\nSeasonCn spring = SeasonCn.SPRING;\nSystem.out.println("序号：" + spring.getValue() + "名称：" + spring.getName());\n}')]),a._v(" "),n("h2",{attrs:{id:"类的抽象"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#类的抽象"}},[a._v("#")]),a._v(" 类的抽象")]),a._v(" "),n("blockquote",[n("p",[a._v("如果只有部分方法为抽象方法，那么这是一个抽象类， 如果全部方法都为抽象方法，那么这是一个借口。")])]),a._v(" "),n("ol",[n("li",[n("p",[a._v("抽象类")]),a._v(" "),n("ol",[n("li",[a._v("关键字"),n("code",[a._v("abstract")]),a._v("来标识抽象方法和抽象类\n2. 抽象方法，由于方法的具体实现不明确，因此没有花括号所包裹着的方法体\n3. 抽象类，不允许外部创建抽象类的实例")])]),a._v(" "),n("p",[a._v("package com.jiangsu.nanjing;")])])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("abstract public class Chicken {\n   public String name;\n   public int sex;\n\n   // 定义一个抽象的叫唤方法\n   abstract public void call();\n\n   public Chicken(){\n\n   }\n}\n")])])]),n("p",[a._v("​"),n("br"),a._v("\npackage com.jiangsu.nanjing;")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('public class Cock extends Chicken {\n   public Cock(){\n       sex = 0;\n   }\n\n   public void call(){\n       System.out.println("喔喔喔");\n   }\n}\n')])])]),n("p",[a._v("​"),n("br"),a._v("\n​"),n("br"),a._v("\npackage com.jiangsu.nanjing;")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("public class TestAbstract {\n   public static void main(String[] args){\n       Cock cock = new Cock();\n       cock.call();\n   }\n\n}\n")])])]),n("p",[a._v("​")]),a._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[n("p",[a._v("简单接口")]),a._v(" "),n("ol",[n("li",[a._v("与类平级，通过关键字"),n("code",[a._v("interface")]),a._v("标识\n2. 接口不允许定义构造方法，只用于声明某些行为\n3. Java8之前，接口内部的所有方法必须是抽象方法\n4. 接口内部的属性，默认是终态属性\n5. 子类不能继承多个父类，但某个类可以实现多个接口")])]),a._v(" "),n("p",[a._v("package com.jiangsu.nanjing;")])])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('public interface Behavior {\n   // 接口内部都是抽象方法，abstract关键字可省略\n   public void fly();\n   public void swim();\n   public void run();\n\n   public String TAG = "动物世界";\n}\n')])])]),n("p",[a._v("​"),n("br"),a._v("\n​"),n("br"),a._v("\npackage com.jiangsu.nanjing;")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('public class Goose extends Bird implements Behavior {\n   public Goose(String name, int sexType, String voice){\n       super(name, sexType, voice);\n   }\n\n   public void fly(){\n       System.out.println("1");\n   }\n\n   public void swim(){\n       System.out.println("2");\n   }\n\n   public void run(){\n       System.out.println("3");\n   }\n}\n')])])]),n("p",[a._v("​"),n("br"),a._v("\n​"),n("br"),a._v("\npackage com.jiangsu.nanjing;")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('public class TestInterface {\n   public static void main(String[] args){\n       testSimple();\n   }\n\n   private static void testSimple(){\n       Goose goose = new Goose("鹅", 0, "鹅鹅鹅");\n       goose.fly();\n       goose.swim();\n       goose.run();\n   }\n}\n')])])]),n("ol",{attrs:{start:"3"}},[n("li",[n("p",[a._v("Java8之后的扩展接口")]),a._v(" "),n("ol",[n("li",[a._v("增加了默认方法，通过前缀"),n("code",[a._v("default")]),a._v("来标识，实现类可直接继承并使用该方法，但不允许重写该方法\n2. 增加了静态属性和静态方法，通过前缀"),n("code",[a._v("static")]),a._v("来标识")]),a._v(" "),n("li",[a._v("静态属性即终态属性")]),a._v(" "),n("li",[a._v("静态方法支持重写，但不能被继承，只能通过扩展接口自身访问")])])]),a._v(" "),n("li",[n("p",[a._v("匿名内部类")]),a._v(" "),n("ol",[n("li",[n("p",[a._v("本质上属于内部类，没有名字,方便，无需额外定义专门的内部类")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(" new 接口名称(){\n")])])]),n("p",[a._v("// 抽象方法\n}")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(" package com.jiangsu.nanjing;\n")])])])])]),a._v(" "),n("p",[a._v("import java.util.Arrays;\nimport java.util.Comparator;")]),a._v(" "),n("p",[a._v("public class TestInterface {\npublic static void main(String[] args){\nsortIntArrayDescAnonymous();\n}")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(' private static void sortIntArrayDescAnonymous(){\n     Integer[] intArray = {89, 3, 67, 12, 45};\n     Arrays.sort(intArray, new Comparator<Integer>() {\n         @Override\n         public int compare(Integer o1, Integer o2) {\n             return Integer.compare(o2, o1);\n         }\n     });\n     String descDesc = "intArray采取匿名内部类的降序结果为：";\n     for (Integer item : intArray){\n         descDesc = descDesc + item + ",";\n     }\n     System.out.println(descDesc);\n }\n')])])]),n("p",[a._v("}")])])]),a._v(" "),n("h2",{attrs:{id:"函数式编程"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#函数式编程"}},[a._v("#")]),a._v(" 函数式编程")]),a._v(" "),n("blockquote",[n("p",[a._v("函数编程本质上是吧函数作为方法的输入参数， Java并未规定函数或方法是一种数据类型，因此需要借助接口来表达函数参数。")])]),a._v(" "),n("ol",[n("li",[n("p",[a._v("Lambda表达式")]),a._v(" "),n("ol",[n("li",[a._v("对匿名内部类的优化")])]),a._v(" "),n("p",[a._v("package com.jiangsu.nanjing;")])])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class TestInterface {\n   public static void main(String[] args){\n       sortIntArrayDescAnonymous();\n   }\n\n   private static void sortIntArrayDescAnonymous(){\n       Integer[] intArray = {89, 3, 67, 12, 45};\n       Arrays.sort(intArray, (o1, o2) -> Integer.compare(o2, o1));  //lambda表达式\n       String descDesc = "intArray采取匿名内部类的降序结果为：";\n       for (Integer item : intArray){\n           descDesc = descDesc + item + ",";\n       }\n       System.out.println(descDesc);\n   }\n\n}\n')])])]),n("ol",{attrs:{start:"2"}},[n("li",[n("p",[a._v("函数式接口的定义")]),a._v(" "),n("ol",[n("li",[a._v("拥有一般接口的形态，但其内部有且仅有一个抽象方法\n2. Java不支持把方法作为参数类型，只好给方法加一层接口的包装")])]),a._v(" "),n("p",[a._v("package com.jiangsu.nanjing;")])])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("public interface Behavior {\n   public void act();\n}\n")])])]),n("p",[a._v("​"),n("br"),a._v("\n​"),n("br"),a._v("\npackage com.jiangsu.nanjing;")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("public class Animal {\n   private String name;\n\n   public Animal(String name){\n       this.name = name;\n   }\n\n   public String getName(){\n       return this.name;\n   }\n\n   public void midnight(Behavior behavior){\n       behavior.act();\n   }\n}\n")])])]),n("p",[a._v("​"),n("br"),a._v("\n​"),n("br"),a._v("\npackage com.jiangsu.nanjing;")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('public class TestAbstract {\n   public static void main(String[] args){\n       testCock();\n   }\n\n   private static void testCock(){\n       Animal cock = new Animal("公鸡");\n       cock.midnight((() -> System.out.println(cock.getName()+"在叫"))); //匿名内部类改写成lambda表达式\n   }\n\n}\n')])])]),n("p",[a._v("​")]),a._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[n("p",[a._v("双冒号标记的方法引用")]),a._v(" "),n("ol",[n("li",[n("p",[a._v("方法引用，只要符合一定的规则，即可将方法名称作为输入参数传进去")]),a._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[n("p",[a._v("变量类型和方法名称之间用双冒号隔开")]),a._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[a._v("像"),n("code",[a._v("isEmpty")]),a._v("这种一元操作可以直接应用方法引用")])]),a._v(" "),n("p",[a._v("resultArray = StringUtil.select(strArray, String::isEmpty);")])])])]),a._v(" "),n("li",[n("p",[a._v("像"),n("code",[a._v("contains，startsWith")]),a._v("这种就需要额外的操作")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(" package com.jiangsu.suzhou;\n")])])])])]),a._v(" "),n("p",[a._v("public interface StringFilter2 {\npublic boolean isMatch(String str, String sign);")]),a._v(" "),n("p",[a._v("}")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v('         public static String[] select2(String[] originArray, StringFilter2 filter2, String sign){\n     int count = 0;\n     String[] resultArray = new String[0];  //新建并初始化\n     for (String str : originArray){\n         if (filter2.isMatch(str, sign)){\n             count++;\n             resultArray = Arrays.copyOf(resultArray, count);  // 数组容量增大一个\n             resultArray[count-1] = str;                       // 向数组末尾填入刚才找到的字符串\n         }\n     }\n   \n     return resultArray;\n }\n\n\n       private static void testSelect2(){\n String[] strArray = {"Hello", "World", "What", "is", "The", "Weather", "today", "o"};\n String[] resultArray;\n resultArray = StringUtil.select2(strArray, String::contains, "e");\n\n for (String str : resultArray){\n     System.out.println(str);\n }\n')])])]),n("p",[a._v("}")]),a._v(" "),n("ol",{attrs:{start:"5"}},[n("li",[n("p",[a._v("更复杂的条件判断就使用正则匹配方法"),n("code",[a._v("matches")])]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(' resultArray = StringUtil.select2(strArray, String::matches, "[wW][a-zA-Z]*");\n')])])])])])]),a._v(" "),n("li",[n("p",[a._v("静态方法引用和实例方法引用")]),a._v(" "),n("ol",[n("li",[n("p",[a._v("参数方法引用")])]),a._v(" "),n("li",[n("p",[a._v("前述")])]),a._v(" "),n("li",[n("p",[a._v("静态方法引用")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(" package com.jiangsu.suzhou;\n")])])])])]),a._v(" "),n("p",[a._v("public interface Calculator {\npublic double operate(double x, double y);\n}")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("       package com.jiangsu.suzhou;\n")])])]),n("p",[a._v("public class Arithmetic {\npublic static double calculate(Calculator calculator, double x, double y){\nreturn calculator.operate(x, y);\n}\n}")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("         private static void testStatic(){\n     double result;\n")])])]),n("p",[a._v("//        result = Arithmetic.calculate((x, y) -> Math.max(x, y), 3, 2);\nresult = Arithmetic.calculate(Math::max, 3, 2);\n}")]),a._v(" "),n("ol",{attrs:{start:"3"}},[n("li",[n("p",[a._v("实例方法引用")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(" package com.jiangsu.suzhou;\n")])])])])]),a._v(" "),n("p",[a._v("public interface Calculator {\npublic double operate(double x, double y);\n}")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("       package com.jiangsu.suzhou;\n")])])]),n("p",[a._v("public class Arithmetic {\npublic static double calculate(Calculator calculator, double x, double y){\nreturn calculator.operate(x, y);\n}\n}")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("       package com.jiangsu.suzhou;\n")])])]),n("p",[a._v("public class MathUtil {\npublic double add(double x, double y){\nreturn x + y;\n}")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v(" public double minus(double x, double y){\n     return x - y;\n }\n   \n public double mutiply(double x, double y){\n     return x * y;\n }\n   \n public double divide(double x, double y){\n     return x / y;\n }\n")])])]),n("p",[a._v("}")]),a._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[a._v("       private static void testInstance(){\n     MathUtil math = new MathUtil();\n     double result;\n     result = Arithmetic.calculate(math::add, 3, 2);\n     result = Arithmetic.calculate(math::minus, 3, 2);\n     result = Arithmetic.calculate(math::mutiply, 3, 2);\n     result = Arithmetic.calculate(math::divide, 3, 2);\n }\n")])])])])])])}),[],!1,null,null,null);t.default=s.exports}}]);